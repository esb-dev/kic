<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1420470600755">{:repl-history {:ide [], :local [&quot;(def sudoku \n  \&quot;The Sudoku world of order 3 comprises the universe of entries,\n  a relation for the grid, and three relations for the regions\&quot; \n  (kic/structure \n     (vec entries)  ; the universe\n     {:grid 3, :region1 1, :region2 1, :region3 1}  ; the relations\n))&quot; &quot;(defn- row \n  \&quot;Returns the row of the number at idx.\&quot;\n  [idx]\n  (inc (quot idx n2)))&quot; &quot;(defn- col \n  \&quot;Returns the col of the number at idx.\&quot;\n  [idx]\n  (inc (rem idx n2)))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for entry c.\&quot;\n  [^Character c ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (= c \\.)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- cells \n  \&quot;Returns the expression for the cells in the grid given by rows and cols.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/dotjoin cols (kic/dotjoin rows (kic/relvar sudoku :grid))))&quot; &quot;(defn- complete \n  \&quot;Returns the formula whether all numbers are in the given cells.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/in kic/UNIV (cells rows cols)))&quot; &quot;(def reg-rules\n  \&quot;for each box b: b = universe.\&quot;\n  (let [r1   (kic/relvar sudoku :region1)\n        r2   (kic/relvar sudoku :region2)\n        r3   (kic/relvar sudoku :region3)]\n    (apply kic/and \n      (for [x [r1 r2 r3] y [r1 r2 r3]]\n        (complete x y)))))&quot; &quot;(def rules\n  \&quot;The rules of Sudoku.\&quot;\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        d    (kic/decls (kic/decl x) (kic/decl y))\n        n    kic/UNIV\n        \n        f1   (kic/all d (kic/one (cells x y)))\n        ; for all x and y: there is one entry in cell x y\n        f2   (kic/all (kic/decl x) (complete x n))\n        ; for all x (rows): x = universe\n        f3   (kic/all (kic/decl y) (complete n y))\n        ; for all y (columns): y = universe\n        ]\n    (kic/and f1 f2 f3 reg-rules)))&quot; &quot;(defn solve-sudoku\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/inst-from-solution sol) 1) :grid))]\n    (apply str (map #(% 2) sol-grid))))&quot; &quot;(def entries\n  \&quot;Entries for cells\&quot;\n  (map #(char (+ (int \\0) %)) (range 1 (inc n2))))&quot; &quot;(def sudoku\n  \&quot;The Sudoku world of order 3 comprises the universe of entries,\n  a relation for the grid, and three relations for the regions\&quot;\n  (kic/structure\n     (vec entries)  ; the universe\n     {:grid 3, :region1 1, :region2 1, :region3 1}  ; the relations\n))&quot; &quot;(def sudoku'\n  \&quot;The Sudoku world of order 3 comprises the universe of entries,\n  a relation for the grid, and three relations for the regions\&quot;\n  (kic/structure\n    (vec entries)  ; the universe\n    {:grid 3, :region1 1, :region2 1, :region3 1}  ; the relations\n    ))&quot; &quot;sudoku'&quot; &quot;entries&quot; &quot;(vec entries)&quot; &quot;sudoku&quot; &quot;(let [r (partition 3 entries)]\n  (def reg1 (rel/unary-rel (first r)))\n  (def reg2 (rel/unary-rel (second r)))\n  (def reg3 (rel/unary-rel (nth r 2))))&quot; &quot;reg1&quot; &quot;reg1-b&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for entry c).\&quot;\n  [^Character c ^Integer idx]\n  (let [row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (= c \\.)\n      #{[row col c]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(upper-tuples \\1 3)&quot; &quot;(upper-tuples \\1 .)&quot; &quot;(upper-tuples \\. 4)&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for entry c.\&quot;\n  [^Character c ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (= c \\.)\n      #{[row col c]}\n      nil)))&quot; &quot;(defn- grid-bounds \n  \&quot;Returns lower and upper bounds of :grid for the given puzzle.\&quot;\n  [^String puzzle]\n  (loop [s puzzle, i 0, lower #{}, upper #{}]\n    (if (empty? s)\n      [lower upper]\n      (recur (next s) (inc i) (set/union lower (lower-tuple (first s) i))\n                              (set/union upper (upper-tuples (first s) i))))))&quot; &quot;(sudoku-bounds puzzle)&quot; &quot;(merge reg1-b reg2-b reg3-b {:grid (grid-bounds puzzle)})&quot; &quot;(grid-bounds puzzle)&quot; &quot;(defn- ctoi\n  \&quot;Returns the int of given char.\&quot;\n  [char]\n  {:pre [(Character/isDigit char)]}\n  (- (int char) (int \\0)))&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for number c (as char).\&quot;\n  [^Character c ^Integer idx]\n  (let [n (ctoi c) row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (= n 0)\n      #{[row col n]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number c.\&quot;\n  [^Character c ^Integer idx]\n  (let [n (ctoi c) row (row idx) col (col idx)]\n    (if-not (= n 0)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for number c (as char).\&quot;\n  [^Character c ^Integer idx]\n  (let [n (ctoi c) row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (= c \\.)\n      #{[row col n]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number c.\&quot;\n  [^Character c ^Integer idx]\n  (let [n (ctoi c) row (row idx) col (col idx)]\n    (if-not (= c \\.)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- grid-bounds\n  \&quot;Returns lower and upper bounds of :grid for the given puzzle.\&quot;\n  [^String puzzle]\n  (loop [s puzzle, i 0, lower #{}, upper #{}]\n    (if (empty? s)\n      [lower upper]\n      (recur (next s) (inc i) (set/union lower (lower-tuple (first s) i))\n             (set/union upper (upper-tuples (first s) i))))))&quot; &quot;(def rules\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        d    (kic/decls (kic/decl x) (kic/decl y))\n        n    kic/UNIV\n\n        f1   (kic/all d (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid)\&quot;\n        f2   (kic/all (kic/decl x) (complete x n))\n        ; \&quot;all x | n in n.(x.grid)\&quot;\n        f3   (kic/all (kic/decl y) (complete n y))\n        ; \&quot;all y | n in y.(n.grid)\&quot;\n        ]\n    (kic/and f1 f2 f3 reg-rules)))&quot; &quot;(defn- ctoi\n  \&quot;Returns the int of given char.\&quot;\n  [char]\n  (- (int char) (int \\0)))&quot; &quot;(def n2 9)&quot; &quot;(def n1 3)&quot; &quot;(ns kic.examples.sudoku\n  (:require [kic.core :as kic])\n  (:require [kic.rel :as rel])\n  (:require [clojure.set :as set])\n  (:require [clojure.string :as str])\n)&quot; &quot;(def puzzle \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;)&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (map vec (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr)))))&quot; &quot;(defn forall\n  \&quot;for all given variables in the universe\&quot;\n  [var-vec fml]\n  (let [d (apply decls (map decl var-vec))]\n    (.forAll fml d)))&quot; &quot;(def puzzle (vec \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;))&quot; &quot;(def sudoku (kic/structure [\\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9]  ; universe atoms are digits 1..9\n              {:grid 3, :region1 1, :region2 1, :region3 1}\n              ))&quot; &quot;(def reg1 (rel/unary-rel [\\1 \\2 \\3]))&quot; &quot;(def reg2 (rel/unary-rel [\\4 \\5 \\6]))&quot; &quot;(def reg3 (rel/unary-rel [\\7 \\8 \\9]))&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for number c (as char).\&quot;\n  [^Character c ^Integer idx]\n  (let [row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (= c \\.)\n      #{[row col c]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number c.\&quot;\n  [^Character c ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (= c \\.)\n      #{[row col c]}\n      nil)))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/inst-from-solution sol) 1) :grid))]\n    (apply str (map #(% 2) sol-grid))))&quot; &quot;(defn pretty-print\n  \&quot;Pretty-printing Sudoku of order 3.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 n2)) (inc (rem %1 n2)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row n1))) (print rule))\n      (if (= 1 (mod col n1)) (print (str \&quot;| \&quot; ch \&quot; \&quot;)) (print (str ch \&quot; \&quot;)))\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(defn pretty-print\n  \&quot;Pretty-printing Sudoku of order 3.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col ch] (map-indexed #(vector (inc (quot %1 9)) (inc (rem %1 9)) %2) puzzle)]\n      (if (and (= 1 col) (= 1 (mod row 3))) (print rule))\n      (if (= 1 (mod col 3)) (print (str \&quot;| \&quot; ch \&quot; \&quot;)) (print (str ch \&quot; \&quot;)))\n      (if (= 9 col) (print \&quot;|\\n\&quot;))\n      )\n    (print rule)))&quot; &quot;(def sudoku (kic/structure\n              (vec (range 1 10))  ; universe atoms are integers 1..9\n              {:grid 3, :region1 1, :region2 1, :region3 1}\n              ))&quot; &quot;(def reg1 (rel/unary-rel (range 1  4)))&quot; &quot;(def reg2 (rel/unary-rel (range 4  7)))&quot; &quot;(def reg3 (rel/unary-rel (range 7 10)))&quot; &quot;(def reg1-b {:region1 [reg1, reg1]})&quot; &quot;(def reg2-b {:region2 [reg2, reg2]})&quot; &quot;(def reg3-b {:region3 [reg3, reg3]})&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number n at idx.\&quot;\n  [^Integer c ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (zero? n)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- cells\n  \&quot;Returns the expression for the cells in the grid given by rows and cols.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/dotjoin cols (kic/dotjoin rows (kic/relvar sudoku :grid))))&quot; &quot;(defn- complete\n  \&quot;Returns the formula whether all numbers are in the given cells.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/in kic/UNIV (cells rows cols)))&quot; &quot;(def reg-rules\n  (let [r1   (kic/relvar sudoku :region1)\n        r2   (kic/relvar sudoku :region2)\n        r3   (kic/relvar sudoku :region3)]\n    (apply kic/and\n           (for [x [r1 r2 r3] y [r1 r2 r3]]\n             (complete x y)))))&quot; &quot;(def rules\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid)\&quot;\n        f2   (kic/forall [x] (complete x n))\n        ; \&quot;all x | n in n.(x.grid)\&quot;\n        f3   (kic/forall [y] (complete n y))\n        ; \&quot;all y | n in y.(n.grid)\&quot;\n        ]\n    (kic/and f1 f2 f3 reg-rules)))&quot; &quot;(pretty-print (first (solve puzzle)))&quot; &quot;(def hardest (parse \&quot;resources/sudoku/hardest.txt\&quot;))&quot; &quot;hardest&quot; &quot;(bench hardest)&quot; &quot;(ns kic.examples.sudoku\n  (:require [kic.core :as kic])\n  (:require [kic.rel :as rel])\n  (:require [clojure.java.io :refer (reader)])\n  (:require [clojure.set :as set])\n)&quot; &quot;(defn ctoi\n  \&quot;Returns the int of given char, 0 if char is '.'.\&quot;\n  [char]\n  (let [i0 (int \\0)]\n    (if (= \\. char) 0 (- (int char) (int \\0)))))&quot; &quot;(def puzzle (map ctoi \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;))&quot; &quot;puzzle&quot; &quot;(def sudoku (kic/structure (vec (range 1 10))  ; atoms of the univers: integers 1..9\n              {:grid 3, :region1 1, :region2 1, :region3 1}))&quot; &quot;(defn- cells\n  \&quot;Expression for the cells in the grid given by rows and cols.\&quot;\n  [rows cols]\n  (kic/dotjoin cols (kic/dotjoin rows (kic/relvar sudoku :grid))))&quot; &quot;(defn- complete\n  \&quot;Formula whether all numbers 1..9 are in the given cells.\&quot;\n  [rows cols]\n  (kic/in kic/UNIV (cells rows cols)))&quot; &quot;(def reg-blocks\n  \&quot;Each block contains all numbers.\&quot;\n  (let [r1   (kic/relvar sudoku :region1)\n        r2   (kic/relvar sudoku :region2)\n        r3   (kic/relvar sudoku :region3)]\n    (apply kic/and\n           (for [x [r1 r2 r3] y [r1 r2 r3]]\n             (complete x y)))))&quot; &quot;(def rules\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid), i.e. Each cell holds exactly one number.\&quot;\n        f2   (kic/forall [x] (complete x n))\n        ; \&quot;all x | n in n.(x.grid), i.e. Each row contains all numbers.\&quot;\n        f3   (kic/forall [y] (complete n y))\n        ; \&quot;all y | n in y.(n.grid), i.e. Each column contains all numbers.\n        ]\n    (kic/and f1 f2 f3 reg-blocks)))&quot; &quot;(let [reg1 (rel/unary-rel (range 1  4))\n      reg2 (rel/unary-rel (range 4  7))\n      reg3 (rel/unary-rel (range 7 10))]\n  (def reg1-b {:region1 [reg1, reg1]})\n  (def reg2-b {:region2 [reg2, reg2]})\n  (def reg3-b {:region3 [reg3, reg3]}))&quot; &quot;(defn- row\n  \&quot;Returns the row of the number at idx.\&quot;\n  [idx]\n  (inc (quot idx 9)))&quot; &quot;(defn- col\n  \&quot;Returns the col of the number at idx.\&quot;\n  [idx]\n  (inc (rem idx 9)))&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for number n at idx.\&quot;\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (zero? n)\n      #{[row col n]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number n at idx.\&quot;\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (zero? n)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- grid-bounds\n  \&quot;Returns lower and upper bounds of :grid for the given puzzle.\&quot;\n  [puzzle]\n  (loop [s puzzle, i 0, lower #{}, upper #{}]\n    (if (empty? s)\n      [lower upper]\n      (recur (next s) (inc i) (set/union lower (lower-tuple (first s) i))\n             (set/union upper (upper-tuples (first s) i))))))&quot; &quot;(defn sudoku-bounds\n  \&quot;Returns bounds for the given puzzle.\&quot;\n  [puzzle]\n  (kic/bounds sudoku (merge reg1-b reg2-b reg3-b {:grid (grid-bounds puzzle)})))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/inst-from-solution sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn model\n  \&quot;vector of outcome and instance &lt;- kodkod.engine.Solution\&quot;\n  [^Solution solution]\n  [(outcome solution) (relmap-from-instmap (.relationTuples (.instance solution)))])&quot; &quot;(defn pretty-print\n  \&quot;Prints puzzle of order 3 decoded as a vector of integers.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 9)) (inc (rem %1 9)) %2) puzzle)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 (mod row 3))) (print rule))\n        (cond (= 1 (mod col 3)) (print (str \&quot;| \&quot; ch ))\n              (= 2 (mod col 3)) (print (str \&quot; \&quot; ch ))\n              (= 0 (mod col 3)) (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= 9 col) (print \&quot;|\\n\&quot;))))\n    (print rule)))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(def rules'\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid), i.e. Each cell holds exactly one number.\&quot;\n        f2   (kic/forall [x y] (kic/no (kic/intersection\n                                         (cells x y)\n                                         (cells x (kic/difference n y)))))\n        f3   (kic/forall [x y] (kic/no (kic/intersection\n                                         (cells x y)\n                                         (cells (kic/difference n x) y))))\n        ]\n    (kic/and f1 f2 f3 reg-blocks)))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules' (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (map #(map ctoi %) (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn bench\n  [puzzles]\n  (time\n    (do\n      (dorun (map solve puzzles))\n      :done)))&quot; &quot;(def easy50 (parse \&quot;resources/sudoku/easy50.txt\&quot;))&quot; &quot;easy50&quot; &quot;(bench easy50)&quot; &quot;(def top95 (parse \&quot;resources/sudoku/top95.txt\&quot;))&quot; &quot;top95&quot; &quot;(bench top95)&quot; &quot;(pretty-print puzzle)&quot; &quot;(pretty-print (solve puzzle))&quot;], :remote []}}</component>
</project>