<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1421746529751">{:repl-history {:ide [], :local [&quot;(def sudoku (kic/structure\n              (vec (range 1 10))  ; universe atoms are integers 1..9\n              {:grid 3, :region1 1, :region2 1, :region3 1}\n              ))&quot; &quot;(def reg1 (rel/unary-rel (range 1  4)))&quot; &quot;(def reg2 (rel/unary-rel (range 4  7)))&quot; &quot;(def reg3 (rel/unary-rel (range 7 10)))&quot; &quot;(def reg1-b {:region1 [reg1, reg1]})&quot; &quot;(def reg2-b {:region2 [reg2, reg2]})&quot; &quot;(def reg3-b {:region3 [reg3, reg3]})&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number n at idx.\&quot;\n  [^Integer c ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (zero? n)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- cells\n  \&quot;Returns the expression for the cells in the grid given by rows and cols.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/dotjoin cols (kic/dotjoin rows (kic/relvar sudoku :grid))))&quot; &quot;(defn- complete\n  \&quot;Returns the formula whether all numbers are in the given cells.\n   Uses var sudoku!\&quot;\n  [rows cols]\n  (kic/in kic/UNIV (cells rows cols)))&quot; &quot;(def reg-rules\n  (let [r1   (kic/relvar sudoku :region1)\n        r2   (kic/relvar sudoku :region2)\n        r3   (kic/relvar sudoku :region3)]\n    (apply kic/and\n           (for [x [r1 r2 r3] y [r1 r2 r3]]\n             (complete x y)))))&quot; &quot;(def rules\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid)\&quot;\n        f2   (kic/forall [x] (complete x n))\n        ; \&quot;all x | n in n.(x.grid)\&quot;\n        f3   (kic/forall [y] (complete n y))\n        ; \&quot;all y | n in y.(n.grid)\&quot;\n        ]\n    (kic/and f1 f2 f3 reg-rules)))&quot; &quot;(pretty-print (first (solve puzzle)))&quot; &quot;hardest&quot; &quot;(ns kic.examples.sudoku\n  (:require [kic.core :as kic])\n  (:require [kic.rel :as rel])\n  (:require [clojure.java.io :refer (reader)])\n  (:require [clojure.set :as set])\n)&quot; &quot;(defn ctoi\n  \&quot;Returns the int of given char, 0 if char is '.'.\&quot;\n  [char]\n  (let [i0 (int \\0)]\n    (if (= \\. char) 0 (- (int char) (int \\0)))))&quot; &quot;puzzle&quot; &quot;(def sudoku (kic/structure (vec (range 1 10))  ; atoms of the univers: integers 1..9\n              {:grid 3, :region1 1, :region2 1, :region3 1}))&quot; &quot;(defn- cells\n  \&quot;Expression for the cells in the grid given by rows and cols.\&quot;\n  [rows cols]\n  (kic/dotjoin cols (kic/dotjoin rows (kic/relvar sudoku :grid))))&quot; &quot;(defn- complete\n  \&quot;Formula whether all numbers 1..9 are in the given cells.\&quot;\n  [rows cols]\n  (kic/in kic/UNIV (cells rows cols)))&quot; &quot;(def reg-blocks\n  \&quot;Each block contains all numbers.\&quot;\n  (let [r1   (kic/relvar sudoku :region1)\n        r2   (kic/relvar sudoku :region2)\n        r3   (kic/relvar sudoku :region3)]\n    (apply kic/and\n           (for [x [r1 r2 r3] y [r1 r2 r3]]\n             (complete x y)))))&quot; &quot;(def rules\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid), i.e. Each cell holds exactly one number.\&quot;\n        f2   (kic/forall [x] (complete x n))\n        ; \&quot;all x | n in n.(x.grid), i.e. Each row contains all numbers.\&quot;\n        f3   (kic/forall [y] (complete n y))\n        ; \&quot;all y | n in y.(n.grid), i.e. Each column contains all numbers.\n        ]\n    (kic/and f1 f2 f3 reg-blocks)))&quot; &quot;(let [reg1 (rel/unary-rel (range 1  4))\n      reg2 (rel/unary-rel (range 4  7))\n      reg3 (rel/unary-rel (range 7 10))]\n  (def reg1-b {:region1 [reg1, reg1]})\n  (def reg2-b {:region2 [reg2, reg2]})\n  (def reg3-b {:region3 [reg3, reg3]}))&quot; &quot;(defn- row\n  \&quot;Returns the row of the number at idx.\&quot;\n  [idx]\n  (inc (quot idx 9)))&quot; &quot;(defn- col\n  \&quot;Returns the col of the number at idx.\&quot;\n  [idx]\n  (inc (rem idx 9)))&quot; &quot;(defn- upper-tuples\n  \&quot;Returns the tuples for the upper bound for number n at idx.\&quot;\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx) univ (kic/univ sudoku)]\n    (if-not (zero? n)\n      #{[row col n]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  \&quot;Returns the tuple for the lower bound for number n at idx.\&quot;\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (zero? n)\n      #{[row col n]}\n      nil)))&quot; &quot;(defn- grid-bounds\n  \&quot;Returns lower and upper bounds of :grid for the given puzzle.\&quot;\n  [puzzle]\n  (loop [s puzzle, i 0, lower #{}, upper #{}]\n    (if (empty? s)\n      [lower upper]\n      (recur (next s) (inc i) (set/union lower (lower-tuple (first s) i))\n             (set/union upper (upper-tuples (first s) i))))))&quot; &quot;(defn sudoku-bounds\n  \&quot;Returns bounds for the given puzzle.\&quot;\n  [puzzle]\n  (kic/bounds sudoku (merge reg1-b reg2-b reg3-b {:grid (grid-bounds puzzle)})))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/inst-from-solution sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn model\n  \&quot;vector of outcome and instance &lt;- kodkod.engine.Solution\&quot;\n  [^Solution solution]\n  [(outcome solution) (relmap-from-instmap (.relationTuples (.instance solution)))])&quot; &quot;(defn pretty-print\n  \&quot;Prints puzzle of order 3 decoded as a vector of integers.\&quot;\n  [puzzle]\n  (let [rule \&quot;+-------+-------+-------+\\n\&quot;]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 9)) (inc (rem %1 9)) %2) puzzle)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 (mod row 3))) (print rule))\n        (cond (= 1 (mod col 3)) (print (str \&quot;| \&quot; ch ))\n              (= 2 (mod col 3)) (print (str \&quot; \&quot; ch ))\n              (= 0 (mod col 3)) (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= 9 col) (print \&quot;|\\n\&quot;))))\n    (print rule)))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(def rules'\n  (let [x    (kic/variable :x)\n        y    (kic/variable :y)\n        n    kic/UNIV\n\n        f1   (kic/forall [x y] (kic/one (cells x y)))\n        ; \&quot;all x, y | one y.(x.grid), i.e. Each cell holds exactly one number.\&quot;\n        f2   (kic/forall [x y] (kic/no (kic/intersection\n                                         (cells x y)\n                                         (cells x (kic/difference n y)))))\n        f3   (kic/forall [x y] (kic/no (kic/intersection\n                                         (cells x y)\n                                         (cells (kic/difference n x) y))))\n        ]\n    (kic/and f1 f2 f3 reg-blocks)))&quot; &quot;(defn solve\n  \&quot;Returns the solution of the puzzle.\&quot;\n  [puzzle]\n  (let  [sol (kic/solve rules' (sudoku-bounds puzzle))\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn ctoi\n  \&quot;Returns the int of given char, 0 if char is '.'.\&quot;\n  [char]\n  (let [i0 (int \\0)]\n    (if (= \\. char) 0 (- (int char) i0))))&quot; &quot;(bench easy50)&quot; &quot;top95&quot; &quot;(bench top95)&quot; &quot;(bench hardest)&quot; &quot;(+ 1460 841 595 527 521 487 497 483 485 479)&quot; &quot;(+ 1314 1277 1263 1280 1266 1282 1249 1265 1249 1244\n   )&quot; &quot;(+ 124 122 120 123 122 119 120 122 119 122)&quot; &quot;(+ (/ 638 50) (/ 1269 95) (/ 121 11))&quot; &quot;(double (+ (/ 638 50) (/ 1269 95) (/ 121 11)))&quot; &quot;easy50&quot; &quot;(dotimes [_ 10]\n  (bench easy50))&quot; &quot;(def hardest (parse \&quot;resources/sudoku/hardest.txt\&quot;))&quot; &quot;(dotimes [_ 10]\n  (bench hardest))&quot; &quot;(def puzzle (map ctoi \&quot;.24...38.6.72.91.481.7.3.96.48...97...........69...51.75.9.8.414.16.57.9.96...83.\&quot;))&quot; &quot;(pretty-print puzzle)&quot; &quot;(pretty-print (solve puzzle))&quot; &quot;(def structure (ls-world 4))&quot; &quot;(def constraints (rules structure))&quot; &quot;(defn- row [idx] (inc (quot idx 4)))&quot; &quot;(defn- col [idx] (inc (rem idx 4)))&quot; &quot;(defn- upper-tuples\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx) univ (kic/univ structure)]\n    (if-not (zero? n)\n      #{[row col n]}\n      (rel/crossjoin #{[row col]} univ))))&quot; &quot;(defn- lower-tuple\n  [^Integer n ^Integer idx]\n  (let [row (row idx) col (col idx)]\n    (if-not (zero? n)\n      #{[1 col col]}\n      nil)))&quot; &quot;(ns kic.examples.latin-square\n  (:require [kic.core :as kic])\n  (:require [kic.rel :as rel])\n  (:require [clojure.set :as set])\n)&quot; &quot;(defn- grid-bounds\n  [givens]\n  (loop [s givens, i 0, lower #{}, upper #{}]\n    (if (empty? s)\n      [lower upper]\n      (recur (next s) (inc i) (set/union lower (lower-tuple (first s) i))\n             (set/union upper (upper-tuples (first s) i))))))&quot; &quot;(defn ls-bounds\n  [givens]\n  (kic/bounds structure {:grid (grid-bounds givens)}))&quot; &quot;(defn solve\n  [givens]\n  (let  [sol (kic/solve constraints (ls-bounds givens))\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn pretty-print\n  [vec n]\n  (let \n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) vec)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (= n col) (print \&quot;\\n\&quot;))))))&quot; &quot;(solve example)&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [rule (str \&quot;+\&quot; (repeat (inc (* 2 n)) \&quot;-\&quot;) \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) vec)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row))) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;)))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [rule (str \&quot;+\&quot; (repeat (inc (* 2 n)) \&quot;-\&quot;) \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) vec)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;)))\n    (print rule))))&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [rule (str \&quot;+\&quot; (repeat (inc (* 2 n)) \&quot;-\&quot;) \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;)))\n    (print rule))))&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [line (str (repeat (inc (* 2 n)) \&quot;-\&quot;))\n        rule (str \&quot;+\&quot; line \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;)))\n    (print rule))))&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [line (apply str (repeat (inc (* 2 n)) \&quot;-\&quot;))\n        rule (str \&quot;+\&quot; line \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;)))\n    (print rule))))&quot; &quot;(def example [1 2 3 4 0 0 0 0 0 0 0 0 0 0 0 0])&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [line (apply str (repeat (inc (* 2 n)) \&quot;-\&quot;))\n        rule (str \&quot;+\&quot; line \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch ))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;))))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [givens n]\n  (let [line (apply str (repeat (inc (* 2 n)) \&quot;-\&quot;))\n        rule (str \&quot;+\&quot; line \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch \&quot; \&quot;))\n                      (print (str \&quot; \&quot; ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;))))\n    (print rule)))&quot; &quot;(defn pretty-print\n  [n givens]\n  (let [line (apply str (repeat (inc (* 2 n)) \&quot;-\&quot;))\n        rule (str \&quot;+\&quot; line \&quot;+\\n\&quot;)]\n    (doseq [[row col dch] (map-indexed #(vector (inc (quot %1 n)) (inc (rem %1 n)) %2) givens)]\n      (let [ch (if (zero? dch) \\. dch)]\n        (if (and (= 1 col) (= 1 row)) (print rule))\n        (if (= 1 col) (print (str \&quot;| \&quot; ch \&quot; \&quot;))\n                      (print (str ch \&quot; \&quot;)))\n        (if (= n col) (print \&quot;|\\n\&quot;))))\n    (print rule)))&quot; &quot;(pretty-print example 4)&quot; &quot;(pretty-print 4 example)&quot; &quot;(pretty-print(solve example))&quot; &quot;(pretty-print 4 (solve example))&quot; &quot;(def lower\n  #{[1 1 1]\n    [1 2 2]\n    [1 3 3]\n    [1 4 4]})&quot; &quot;(def upper\n  #{[1 1 1]\n    [1 2 2]\n    [1 3 3]\n    [1 4 4]\n    [2 1 1] [2 1 2] [2 1 3] [2 1 4]\n    [2 2 1] [2 2 2] [2 2 3] [2 2 4]\n    [2 3 1] [2 3 2] [2 3 3] [2 3 4]\n    [2 4 1] [2 4 2] [2 4 3] [2 4 4]\n    [3 1 1] [3 1 2] [3 1 3] [3 1 4]\n    [3 2 1] [3 2 2] [3 2 3] [3 2 4]\n    [3 3 1] [3 3 2] [3 3 3] [3 3 4]\n    [3 4 1] [3 4 2] [3 4 3] [3 4 4]\n    [4 1 1] [4 1 2] [4 1 3] [4 1 4]\n    [4 2 1] [4 2 2] [4 2 3] [4 2 4]\n    [4 3 1] [4 3 2] [4 3 3] [4 3 4]\n    [4 4 1] [4 4 2] [4 4 3] [4 4 4]})&quot; &quot;(def bounds \n  (kic/bounds structure {:grid [lower upper]}))&quot; &quot;(defn solve-example\n (let  [sol (kic/solve constraints bounds)\n         sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn solve-example\n (let  [sol (kic/solve constraints bounds)\n        sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(defn solve-example []\n (let  [sol (kic/solve constraints bounds)\n        sol-grid (sort (((kic/model sol) 1) :grid))]\n    (map #(% 2) sol-grid)))&quot; &quot;(pretty-print 4 (solve-example))&quot; &quot;(defn parse\n  \&quot;Parses file with filename and returns a list of puzzles.\&quot;\n  [filename]\n  (with-open [rdr (reader filename)]\n    (into () (map #(map ctoi %) (filter #(re-matches #\&quot;^([1-9]|\\.){81}$\&quot; %) (line-seq rdr))))))&quot; &quot;(defn bench\n  [puzzles]\n  (time\n    (do\n      (dorun (map solve puzzles))\n      :done)))&quot; &quot;(def easy50 (parse \&quot;resources/sudoku/easy50.txt\&quot;))&quot; &quot;(def top95 (parse \&quot;resources/sudoku/top95.txt\&quot;))&quot; &quot;(dotimes [_ 10]\n  (bench top95))&quot; &quot;(def p88 (nth top95 88))&quot; &quot;(def p92 (nth top95 92))&quot; &quot;(- 81 (count (filter zero? p88)))&quot; &quot;(time (solve p88))&quot; &quot;(- 81 (count (filter zero? p92)))&quot; &quot;(time (solve p92))&quot; &quot;(class (map solve top95))&quot; &quot;(class (dorun (map solve top95)))&quot; &quot;(class (doall (map solve top95)))&quot; &quot;(map solve top95)&quot; &quot;(time (map solve top95))&quot; &quot;(time (dorun (map solve top95)))&quot;], :remote []}}</component>
</project>